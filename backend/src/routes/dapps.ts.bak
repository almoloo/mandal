import { Hono } from 'hono';
import prisma from '../lib/db.js';
import { ChainId, getNewContractInfo } from '../lib/explorer.js';
import { analyzeContractWithAI } from '../services/ai-analysis.service.js';
import { analyzeDAppWithAI } from '../services/dapp-analysis.service.js';
import {
	getDAppMetadata,
	getDomainWhoisData,
} from '../services/metadata.service.js';

const dapps = new Hono();

// Helper to add delay between API calls
const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

// Get DApp with connected contracts
// Query Params: url (required), chainId (optional), contracts (optional comma-separated), model (optional)
dapps.get('/', async (c) => {
	const url = c.req.query('url');
	const chainId = (
		c.req.query('chainId')
			? Number(c.req.query('chainId'))
			: ChainId.MantleMainnet
	) as ChainId;
	const contracts = c.req.query('contracts');
	const model = c.req.query('model') || 'gpt-4o';
	let contractsArray: string[] | undefined = undefined;

	if (!url) {
		return c.json({ success: false, error: 'URL is required' }, 400);
	}

	if (contracts) {
		contractsArray = contracts.split(',').map((addr) => addr.toLowerCase());
	}

	try {
		const dapp = await prisma.dApp.findUnique({
			where: { url },
			include: {
				connectedContracts: {
					include: {
						contract: {
							include: {
								analyses: {
									orderBy: { createdAt: 'desc' },
									take: 1,
								},
							},
						},
					},
				},
				userReports: {
					where: { status: 'APPROVED' },
					orderBy: { createdAt: 'desc' },
					take: 10,
				},
			},
		});

		if (!dapp) {
			let contractsInfo: any[] = [];

			if (contractsArray && contractsArray.length > 0) {
				// Fetch contract info from DB
				contractsInfo = await prisma.contract.findMany({
					where: {
						address: {
							in: contractsArray,
						},
						chainId: Number(chainId),
					},
					include: {
						analyses: {
							orderBy: { createdAt: 'desc' },
							take: 1,
						},
					},
				});

				// Analyze existing contracts that don't have analysis yet
				console.log(
					`[DAPP] Found ${contractsInfo.length} existing contracts in DB`
				);
				for (let i = 0; i < contractsInfo.length; i++) {
					const contract = contractsInfo[i];
					console.log(
						`[DAPP] Checking contract ${
							contract.address
						}: verified=${
							contract.verified
						}, hasSource=${!!contract.sourceCode}, hasABI=${!!contract.abi}, analysisCount=${
							contract.analyses?.length || 0
						}`
					);
					if (
						contract.verified &&
						contract.sourceCode &&
						contract.abi &&
						(!contract.analyses || contract.analyses.length === 0)
					) {
						try {
							console.log(
								'Analyzing existing contract without analysis:',
								contract.address
							);
							const aiAnalysis = await analyzeContractWithAI(
								{
									id: contract.id,
									address: contract.address,
									chainId: contract.chainId,
									name: contract.name,
									verified: contract.verified,
									sourceCode: contract.sourceCode,
									abi: JSON.stringify(contract.abi),
									compilerVersion: contract.compilerVersion,
									optimizationUsed: contract.optimizationUsed,
									runs: contract.runs,
									constructorArgs: contract.constructorArgs,
									createdAt: contract.createdAt,
									updatedAt: contract.updatedAt,
									creatorAddress: contract.creatorAddress,
								},
								model
							);

							// Save analysis to database
							const newAnalysis =
								await prisma.securityAnalysis.create({
									data: {
										contractId: contract.id,
										version: 1,
										riskLevel: aiAnalysis.riskLevel,
										summary: aiAnalysis.summary,
										detailedAnalysis:
											aiAnalysis.detailedAnalysis,
										isHoneypot: aiAnalysis.isHoneypot,
										hasUnlimitedMint:
											aiAnalysis.hasUnlimitedMint,
										hasHiddenFees: aiAnalysis.hasHiddenFees,
										hasBlacklist: aiAnalysis.hasBlacklist,
										isUpgradeable: aiAnalysis.isUpgradeable,
										ownerCanPause: aiAnalysis.ownerCanPause,
										ownerCanDrain: aiAnalysis.ownerCanDrain,
										functionAnalysis:
											aiAnalysis.functionAnalysis,
										vulnerabilities:
											aiAnalysis.vulnerabilities,
										externalCalls: aiAnalysis.externalCalls,
										aiModel: aiAnalysis.aiModel,
										analysisTime: Math.floor(
											aiAnalysis.analysisTime.getTime()
										),
									},
								});

							// Update the contract in contractsInfo with the new analysis
							console.log(
								`[DAPP] Successfully saved analysis for existing contract ${contract.address}, analysis ID: ${newAnalysis.id}`
							);
							contractsInfo[i] = {
								...contract,
								analyses: [newAnalysis],
							};

							// Delay to avoid rate limiting
							await delay(2000);
						} catch (error) {
							console.error(
								'Failed to analyze existing contract',
								contract.address,
								error
							);
							// Continue without analysis
						}
					}
				}

				// If some contracts are not in DB, fetch from explorer and add to DB
				const existingAddresses = contractsInfo.map((c) => c.address);
				const missingAddresses = contractsArray.filter(
					(addr) => !existingAddresses.includes(addr)
				);
				console.log(
					`[DAPP] Missing contracts to fetch: ${missingAddresses.length}`,
					missingAddresses
				);

				for (const address of missingAddresses) {
					console.log(
						`[DAPP] Fetching new contract info for ${address}`
					);
					const newContractInfo = await getNewContractInfo(
						address,
						chainId
					);

					const newContract = await prisma.contract.create({
						data: {
							address: address.toLowerCase(),
							chainId: Number(chainId),
							name:
								newContractInfo.sourceCode['ContractName'] ||
								null,
							verified: newContractInfo.isVerified,
							sourceCode:
								newContractInfo.sourceCode['SourceCode'] ||
								null,
							abi: newContractInfo.isVerified
								? JSON.parse(newContractInfo.sourceCode['ABI'])
								: null,
							compilerVersion:
								newContractInfo.sourceCode['CompilerVersion'] ||
								null,
							optimizationUsed:
								newContractInfo.sourceCode[
									'OptimizationUsed'
								] === '1',
							runs: newContractInfo.sourceCode['Runs']
								? parseInt(newContractInfo.sourceCode['Runs'])
								: null,
							constructorArgs:
								newContractInfo.sourceCode[
									'ConstructorArguments'
								] || null,
							creatorAddress:
								newContractInfo.creator.contractCreator,
							createdAt: new Date(
								parseInt(newContractInfo.creator.timestamp) *
									1000
							),
						},
					});

					// ANALYZE NEW CONTRACT (only if verified)
					console.log(
						`[DAPP] New contract ${address} created with ID ${
							newContract.id
						}. Verified: ${
							newContractInfo.isVerified
						}, hasSource: ${!!newContract.sourceCode}, hasABI: ${!!newContract.abi}`
					);
					let contractAnalysis = null;
					if (
						newContractInfo.isVerified &&
						newContract.sourceCode &&
						newContract.abi
					) {
						console.log(
							`[DAPP] Starting analysis for new contract ${address}`
						);
						try {
							const aiAnalysis = await analyzeContractWithAI(
								{
									id: newContract.id,
									address: newContract.address,
									chainId: newContract.chainId,
									name: newContract.name,
									verified: newContract.verified,
									sourceCode: newContract.sourceCode,
									abi: JSON.stringify(newContract.abi),
									compilerVersion:
										newContract.compilerVersion,
									optimizationUsed:
										newContract.optimizationUsed,
									runs: newContract.runs,
									constructorArgs:
										newContract.constructorArgs,
									createdAt: newContract.createdAt,
									updatedAt: newContract.updatedAt,
									creatorAddress: newContract.creatorAddress,
								},
								model
							);

							// Save analysis to database
							console.log(
								`[DAPP] Saving analysis for new contract ${address}`
							);
							contractAnalysis =
								await prisma.securityAnalysis.create({
									data: {
										contractId: newContract.id,
										version: 1,
										riskLevel: aiAnalysis.riskLevel,
										summary: aiAnalysis.summary,
										detailedAnalysis:
											aiAnalysis.detailedAnalysis,
										isHoneypot: aiAnalysis.isHoneypot,
										hasUnlimitedMint:
											aiAnalysis.hasUnlimitedMint,
										hasHiddenFees: aiAnalysis.hasHiddenFees,
										hasBlacklist: aiAnalysis.hasBlacklist,
										isUpgradeable: aiAnalysis.isUpgradeable,
										ownerCanPause: aiAnalysis.ownerCanPause,
										ownerCanDrain: aiAnalysis.ownerCanDrain,
										functionAnalysis:
											aiAnalysis.functionAnalysis,
										vulnerabilities:
											aiAnalysis.vulnerabilities,
										externalCalls: aiAnalysis.externalCalls,
										aiModel: aiAnalysis.aiModel,
										analysisTime: Math.floor(
											aiAnalysis.analysisTime.getTime()
										),
									},
								});
							console.log(
								`[DAPP] Successfully saved analysis for new contract ${address}, analysis ID: ${contractAnalysis.id}`
							);
						} catch (error) {
							console.error(
								'[DAPP] Contract analysis failed for',
								address,
								error
							);
							// Continue without analysis - don't fail the whole request
						}
					} else {
						console.log(
							`[DAPP] Skipping analysis for ${address} - Contract not verified or missing source/ABI`
						);
					}

					// Add analysis to contract object for response
					contractsInfo.push({
						...newContract,
						analyses: contractAnalysis ? [contractAnalysis] : [],
					});
					console.log(
						`[DAPP] Added contract ${address} to contractsInfo with ${
							contractAnalysis ? '1' : '0'
						} analyses`
					);
				}
			}

			// Extract domain from URL
			const domain = new URL(url).hostname;

			// Fetch metadata and domain WHOIS data
			console.log(`[DAPP] Fetching metadata for ${url}`);
			const [metadata, whoisData] = await Promise.all([
				getDAppMetadata(url),
				getDomainWhoisData(domain),
			]);
			console.log(
				`[DAPP] Metadata fetched - Title: ${metadata.title}, Domain Age: ${whoisData.domainAge} days`
			);

			// Create or get DApp in database
			const newDApp = await prisma.dApp.upsert({
				where: { url },
				update: {
					title: metadata.title,
					description: metadata.description,
					domainAge: whoisData.domainAge,
				},
				create: {
					url,
					domain,
					title: metadata.title,
					description: metadata.description,
					domainAge: whoisData.domainAge,
				},
			}); // Link contracts to DApp (skip if already linked)
			if (contractsInfo.length > 0) {
				// Check which contracts are already linked
				const existingLinks = await prisma.dAppContract.findMany({
					where: {
						dappId: newDApp.id,
						contractId: {
							in: contractsInfo.map((c) => c.id),
						},
					},
				});

				const existingContractIds = new Set(
					existingLinks.map((link) => link.contractId)
				);

				// Only create links for contracts that aren't already linked
				const newLinks = contractsInfo
					.filter((contract) => !existingContractIds.has(contract.id))
					.map((contract) => ({
						dappId: newDApp.id,
						contractId: contract.id,
					}));

				if (newLinks.length > 0) {
					await prisma.dAppContract.createMany({
						data: newLinks,
					});
					console.log(
						`[DAPP] Linked ${newLinks.length} new contracts to DApp`
					);
				}
			} // ANALYZE DAPP WITH AI
			const dappAnalysis = await analyzeDAppWithAI(
				{
					url,
					domain,
					title: newDApp.title || undefined,
					description: newDApp.description || undefined,
					connectedContracts: contractsInfo.map((contract) => ({
						address: contract.address,
						name: contract.name || undefined,
						verified: contract.verified,
						latestAnalysis: contract.analyses?.[0]
							? {
									riskLevel: contract.analyses[0].riskLevel,
									summary: contract.analyses[0].summary,
									isHoneypot:
										contract.analyses[0].isHoneypot ||
										undefined,
									hasHiddenFees:
										contract.analyses[0].hasHiddenFees ||
										undefined,
							  }
							: undefined,
					})),
				},
				model
			);

			// Update DApp with analysis results
			const updatedDApp = await prisma.dApp.update({
				where: { id: newDApp.id },
				data: {
					sslValid: dappAnalysis.sslValid,
					isPhishing: dappAnalysis.isPhishing,
				},
				include: {
					connectedContracts: {
						include: {
							contract: {
								include: {
									analyses: {
										orderBy: { createdAt: 'desc' },
										take: 1,
									},
								},
							},
						},
					},
					userReports: {
						where: { status: 'APPROVED' },
						orderBy: { createdAt: 'desc' },
						take: 10,
					},
				},
			});

			return c.json({
				success: true,
				data: {
					dapp: updatedDApp,
					analysis: dappAnalysis,
					contracts: contractsInfo,
				},
				message: 'DApp analyzed successfully',
			});
		}

		// DAPP EXISTS IN DATABASE
		// Check if we need to analyze it (no analysis done yet or re-analysis requested)
		let dappAnalysis = null;

		// Prepare contract data for analysis
		const contractsForAnalysis = dapp.connectedContracts.map((dc) => ({
			address: dc.contract.address,
			name: dc.contract.name || undefined,
			verified: dc.contract.verified,
			latestAnalysis: dc.contract.analyses?.[0]
				? {
						riskLevel: dc.contract.analyses[0].riskLevel,
						summary: dc.contract.analyses[0].summary,
						isHoneypot:
							dc.contract.analyses[0].isHoneypot || undefined,
						hasHiddenFees:
							dc.contract.analyses[0].hasHiddenFees || undefined,
				  }
				: undefined,
		}));

		// Check if DApp needs analysis (no sslValid means it hasn't been analyzed)
		if (dapp.sslValid === null || dapp.sslValid === undefined) {
			try {
				dappAnalysis = await analyzeDAppWithAI(
					{
						url: dapp.url,
						domain: dapp.domain,
						title: dapp.title || undefined,
						description: dapp.description || undefined,
						connectedContracts: contractsForAnalysis,
					},
					model
				);

				// Update DApp with analysis results
				await prisma.dApp.update({
					where: { id: dapp.id },
					data: {
						sslValid: dappAnalysis.sslValid,
						isPhishing: dappAnalysis.isPhishing,
					},
				});

				// Update the dapp object with new values
				dapp.sslValid = dappAnalysis.sslValid;
				dapp.isPhishing = dappAnalysis.isPhishing;
			} catch (error) {
				console.error('DApp analysis failed:', error);
				// Continue without analysis - don't fail the whole request
			}
		}

		return c.json({
			success: true,
			data: {
				dapp,
				analysis: dappAnalysis || {
					sslValid: dapp.sslValid,
					isPhishing: dapp.isPhishing,
					message: 'Using cached analysis',
				},
				contracts: dapp.connectedContracts.map((dc) => dc.contract),
			},
		});
	} catch (error) {
		console.error('Error fetching DApp:', error);
		return c.json({ success: false, error: 'Failed to fetch DApp' }, 500);
	}
});

export default dapps;
